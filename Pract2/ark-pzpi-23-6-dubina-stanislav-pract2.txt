МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ

ФАКУЛЬТЕТ КОМП’ЮТЕРНИХ НАУК
КАТЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ




ЗВІТ
до практичного завдання №2 з дисципліни
«Аналіз та рефакторинґ коду»
на тему: «Методи рефакторинґу коду програмного забезпечення: Convert Procedural Design to Objects, Replace Data Value with Object, Replace Method with Method Object»






Виконав:                                                                                                  Перевірив:
ст. гр. ПЗПІ-23-6                       				ст. викладач катедри ПІ
Дубіна Станіслав Геннадійович		                    Сокорчук Ігор Петрович







Харків 2025
1 ІСТОРІЯ ЗМІН 

№ДатаВерсія звітуОпис змін та виправлень130.11.20251Створено звіт


2 ЗАВДАННЯ

     Мета цієї практичної роботи - детально вивчити та застосувати методи рефакторингу для покращення внутрішньої структури коду без зміни його функціональності, а також проаналізувати вплив цих змін на якість програмного продукту. Мені потрібно ознайомитися з основними підходами до рефакторингу з книги Мартіна Фаулера, обрати три різні методи та показати їх використання на фрагментах мого власного коду з попередніх лабораторних робіт або курсових проєктів.
     Я маю знайти у своєму коді місця з "запахами коду" або структурними проблемами і виправити їх за допомогою обраних технік рефакторингу. Для кожного прикладу потрібно підготувати порівняння стану коду "до" та "після" змін, пояснити чому саме цей рефакторинг необхідний, яку проблему він вирішує, та описати переваги результату з точки зору читабельності, гнучкості та простоти підтримки коду.
     На основі виконаної роботи я маю створити презентацію, яка включає теоретичний вступ про рефакторинг, детальний аналіз трьох прикладів рефакторингу з мого коду, огляд можливостей автоматичного рефакторингу в сучасних IDE (WebStorm, VSCode), а також висновки про важливість регулярного покращення якості кодової бази.
      

3 ОПИС ВИКОНАНОЇ РОБОТИ
     3.1 Вибір мови програмування та джерел
     Для виконання практичної роботи я обрав три методи рефакторинґу з каталогу Мартіна Фаулера. Мета їх застосування - зробити код більш зрозумілим, зменшити складність та покращити архітектуру. Усі приклади виконані на TypeScript.
     Обрані методи рефакторинґу:
- Convert Procedural Design to Objects (перетворення процедурного коду в об'єктний) - використовується для об'єднання даних та функцій, які з ними працюють, в один клас, що покращує інкапсуляцію та зменшує кількість параметрів, що передаються між функціями.
- Replace Data Value with Object (заміна примітивного значення об'єктом) - застосовується коли примітивний тип (string, number) використовується для представлення складної концепції, і його потрібно замінити на Value Object з валідацією та бізнес-логікою.
- Replace Method with Method Object (заміна методу об'єктом-методом) - дозволяє перетворити довгий метод з великою кількістю локальних змінних у окремий клас, де локальні змінні стають полями, а етапи обчислень - методами, що значно покращує читабельність та тестованість коду.

3.2 Метод Convert Procedural Design to Objects (перетворення процедурного коду в об'єктний)
     Даний метод рефакторинґу застосовується для об'єднання даних та функцій, які з ними працюють, в один клас. Це дозволяє інкапсулювати поведінку разом з даними, зменшити кількість параметрів, що передаються між функціями, та покращити структуру коду.
     У вихідній реалізації сервісу статистики дані про події годування передавалися як масив між різними функціями. Головною проблемою був процедурний підхід: одні й ті ж дані ітерувалися багато разів у різних функціях (calculateStats, calculateDailyBreakdown), що призводило до неефективності та дублювання логіки. Кожна функція окремо обробляла масив подій, обчислюючи різні метрики. Це робило код важким для розуміння та тестування, оскільки логіка була розкидана по різних методах, а дані "мандрували" між ними як параметри.
     
1  const events = await this.getEventsInRange(deviceId, startDate, endDate);
2  
3  const totalFeedings = this.calculateTotal(events);
4  const totalFood = this.calculateFood(events);
5  const dailyBreakdown = this.calculateDaily(events, startDate, endDate);
6  
7  private calculateTotal(events: FeedingEvent[]): number {
8    return events.length;
9  }
10 
11 private calculateFood(events: FeedingEvent[]): number {
12   return events.reduce((sum, e) => sum + e.portionSize, 0);
13 }
14 
15 private calculateDaily(
16   events: FeedingEvent[], 
17   startDate: Date, 
18   endDate: Date
19 ): DailyStats[] {
20   for (const event of events) {
21     // Обробка подій...
22   }
23 }

     В результаті рефакторинґу створено клас FeedingStatistics, який інкапсулює дані про події годування та всю логіку їх обробки. Локальні змінні з різних функцій перетворилися на поля класу, а функції-утиліти стали приватними методами. Ключовою перевагою є те, що всі обчислення виконуються за одну ітерацію в конструкторі, а результати кешуються в полях класу. Публічні методи (getTotalFeedings(), getTotalFood()) забезпечують доступ до обчислених значень.
     Такий підхід забезпечив інкапсуляцію: дані та поведінка об'єднані в одному місці. Код став більш ефективним (одна ітерація замість п'яти), читабельним (stats.getTotalFeedings() замість calculateTotal(events)) та легше тестується як ізольований об'єкт. 
     
1  class FeedingStatistics {
2    private readonly totalFeedings: number;
3    private readonly totalFood: number;
4    private readonly dailyBreakdown: Map<string, DailyStats>;
5  
6    constructor(private readonly events: FeedingEvent[]) {
7      this.totalFeedings = 0;
8      this.totalFood = 0;
9      this.dailyBreakdown = new Map();
10     this.calculateAllStats();
11   }
12 
13   private calculateAllStats(): void {
14     for (const event of this.events) {
15       this.totalFeedings++;
16       this.totalFood += event.portionSize;
17       this.updateDailyBreakdown(event);
18     }
19   }
20 
21   getTotalFeedings(): number { return this.totalFeedings; }
22   getTotalFood(): number { return this.totalFood; }
23   getDailyBreakdown(): DailyStats[] { 
24     return Array.from(this.dailyBreakdown.values()); 
25   }
26 }
27 
28 const stats = new FeedingStatistics(events);
29 const totalFeedings = stats.getTotalFeedings();
30 const totalFood = stats.getTotalFood();
     3.3 Метод Replace Data Value with Object (заміна примітивного значення об'єктом)
     Даний метод рефакторинґу передбачає заміну примітивних типів даних (string, number) на повноцінні Value Objects, коли примітив використовується для представлення складної бізнес-концепції. Це дозволяє централізувати валідацію, форматування та бізнес-логіку в одному місці.
     У початковому варіанті час годування (feedingTime) представлявся простим рядком у форматі "HH:MM". Головною проблемою було дублювання валідації: регулярний вираз для перевірки формату часу повторювався і в DTO декораторі, і в утилітах. Логіка роботи з часом була розкидана по різних функціях (timeToMinutes, isValidTimeFormat), які працювали з примітивним рядком. Бізнес-правила, такі як перевірка мінімального інтервалу між годуваннями, змішувалися з математичними обчисленнями (Math.abs(minutes1 - minutes2) >= 120), що ускладнювало читабельність коду.
     
1  @Matches(/^([01]\d|2[0-3]):([0-5]\d)$/, {
2    message: 'feedingTime must be in HH:MM format',
3  })
4  feedingTime: string;
5  
6  export function timeToMinutes(timeString: string): number {
7    const [hours, minutes] = timeString.split(':').map(Number);
8    return hours * 60 + minutes;
9  }
10 
11 export function isValidTimeFormat(timeString: string): boolean {
12   const timeRegex = /^([01]\d|2[0-3]):([0-5]\d)$/;
13   return timeRegex.test(timeString);
14 }
15 
16 const newTimeInMinutes = timeToMinutes(feedingTime);
17 const existingTimeInMinutes = timeToMinutes(existingSchedule.feedingTime);
18 const timeDifference = Math.abs(newTimeInMinutes - existingTimeInMinutes);
19 
20 if (timeDifference < MIN_INTERVAL_HOURS * 60) {
21   throw new BadRequestException('Schedules too close');
22 }

     В результаті рефакторинґу створено клас FeedingTime, який інкапсулює всю логіку роботи з часом годування. Валідація тепер виконується в конструкторі, що унеможливлює створення об'єкта з невалідним значенням. Регулярний вираз винесено в приватну константу класу, що усуває дублювання. Бізнес-правило про мінімальний інтервал між годуваннями виражене як метод meetsMinimumInterval() з чіткою назвою, що робить код самодокументованим.
     Такий підхід забезпечив централізацію логіки: вся робота з часом зосереджена в одному класі. Код став більш читабельним (newTime.meetsMinimumInterval(existingTime, 2) замість складних математичних виразів) та безпечним (неможливо створити об'єкт з невалідним часом).
     
1  class FeedingTime {
2    private static readonly TIME_REGEX = /^([01]\d|2[0-3]):([0-5]\d)$/;
3    private readonly hours: number;
4    private readonly minutes: number;
5  
6    constructor(timeString: string) {
7      if (!FeedingTime.TIME_REGEX.test(timeString)) {
8        throw new BadRequestException('Invalid time format');
9      }
10     [this.hours, this.minutes] = timeString.split(':').map(Number);
11   }
12 
13   toMinutes(): number {
14     return this.hours * 60 + this.minutes;
15   }
16 
17   meetsMinimumInterval(other: FeedingTime, minHours: number): boolean {
18     const diff = Math.abs(this.toMinutes() - other.toMinutes());
19     return diff >= minHours * 60;
20   }
21 }
22 
23 const newTime = new FeedingTime(feedingTime);
24 const existingTime = new FeedingTime(existingSchedule.feedingTime);
25 
26 if (!newTime.meetsMinimumInterval(existingTime, 2)) {
27   throw new BadRequestException('Schedules too close');
28 }
     3.4 Метод Replace Method with Method Object (заміна методу об'єктом-методом)
     Цей метод рефакторинґу передбачає перетворення довгого методу з великою кількістю локальних змінних у окремий клас. Локальні змінні стають полями класу, а етапи обчислень виділяються в окремі методи, що значно покращує читабельність та можливість тестування окремих кроків алгоритму.
     У вихідному коді метод calculateDailyRecommendation містив понад 150 рядків коду та 15+ локальних змінних. Головною проблемою була змішана абстракція: в одному методі відбувалося обчислення базового споживання, аналіз трендів, розрахунок множників віку, активності, здоров'я та погоди. Локальні змінні (totalFoodConsumed, ageMultiplier, activityMultiplier тощо) заплутувалися між собою, а логіку різних етапів обчислень було неможливо протестувати окремо. Весь метод приходилося тестувати як чорну скриньку, що ускладнювало виявлення помилок у конкретних розрахунках.
     
      1 async calculateDailyRecommendation(petId: string): Promise<Recommendation> {
      2    let totalFoodConsumed = 0;
      3    let averageDailyConsumption = 0;
      4    let consumptionTrend = 0;
      5    let morningFeedingsCount = 0;
      6    let eveningFeedingsCount = 0;
      7    let ageMultiplier = 1.0;
      8    let activityMultiplier = 1.0;
      9    let healthMultiplier = 1.0;
      10    let weatherMultiplier = 1.0;
      11    let recommendedDailyAmount = 0;
      12    let recommendedPortionSize = 0;
      13    let alertMessages: string[] = [];
      14    
      15 for (const event of events) {
      16    totalFoodConsumed += event.portionSize;
      17    const hour = event.timestamp.getHours();
      18    if (hour >= 5 && hour < 12) morningFeedingsCount++;
      19 }
      20 
      21 const recentAvg = recentWeek.reduce(...) / 7;
      22 consumptionTrend = ((recentAvg - olderAvg) / olderAvg) * 100;
      23 
      24 return { recommendedDailyAmount, recommendedPortionSize, ... };
      25 }
     В результаті рефакторинґу створено клас FeedingRecommendationCalculator, який інкапсулює всю логіку обчислень. Локальні змінні перетворилися на приватні поля класу, що дозволило позбутися їх передачі між кроками алгоритму. Кожен етап обчислень виділено в окремий метод (calculateBaseConsumption(), calculateAgeMultiplier(), calculateActivityMultiplier() тощо), що зробило код самодокументованим. Головний метод calculate() тепер є оркестратором, який викликає кроки у правильній послідовності.
     Такий підхід забезпечив можливість тестування окремих кроків: кожен метод можна протестувати незалежно через геттери класу. Код став значно читабельнішим (15 рядків на метод замість 150), а складність знизилася завдяки чіткому розділенню відповідальності.
     
1 class FeedingRecommendationCalculator {
2    private totalFoodConsumed = 0;
3    private averageDailyConsumption = 0;
4    private morningFeedingsCount = 0;
5    private ageMultiplier = 1.0;
6    private activityMultiplier = 1.0;
7    private recommendedDailyAmount = 0;
8
9    constructor(private pet: Pet, private events: FeedingEvent[]) {}
10 
11    calculate(): Recommendation {
12        this.calculateBaseConsumption();
13        this.analyzeConsumptionTrend();
14        this.calculateAgeMultiplier();
15        this.calculateActivityMultiplier();
16        this.calculateFinalRecommendation();
17
18        return this.buildRecommendation();
19    }
20
21    private calculateBaseConsumption(): void {
22        for (const event of this.events) {
23            this.totalFoodConsumed += event.portionSize;
24        }
25    }
26
27    private calculateAgeMultiplier(): void {
28        const ageInMonths = this.getAgeInMonths();
29        if (ageInMonths < 6) this.ageMultiplier = 1.5;
30    }
31    
32    getMultipliers() { return { age: this.ageMultiplier, ... }; }
33 }
34
35 const calculator = new FeedingRecommendationCalculator(pet, events);
36 return calculator.calculate();

ВИСНОВКИ

     У ході виконання практичної роботи я дослідив та успішно застосував три методи рефакторинґу коду на TypeScript. Використання технік Replace Data Value with Object, Convert Procedural Design to Objects та Replace Method with Method Object дозволило перетворити складні фрагменти коду у зрозумілі та гнучкі структури.
     Зокрема, мені вдалося усунути типові проблеми: дублювання валідації примітивних типів, процедурний підхід з розкиданою логікою та довгі методи з великою кількістю локальних змінних. Практичні приклади показали, що заміна примітивів на Value Objects централізує валідацію та бізнес-логіку, перетворення процедурного коду в об'єктний покращує інкапсуляцію та ефективність, а виділення Method Object робить складні алгоритми читабельними та тестованими.
     Робота підтвердила, що регулярний рефакторинґ є необхідною практикою для підтримки якості коду. Сучасні IDE, такі як WebStorm та VSCode, надають потужні інструменти автоматизації базових рефакторинґів, але складні структурні перетворення потребують глибокого розуміння принципів та свідомого застосування відповідних методів. Отримані навички дозволять мені систематично покращувати архітектуру коду у майбутніх проєктах.
     

ВИКОРИСТАНІ ДЖЕРЕЛА

1. Fowler M. Refactoring: Improving the Design of Existing Code (2nd Edition). URL: https://refactoring.com (дата звернення: 30.11.2025).
2. Refactoring.Guru. Catalog of Refactoring Patterns. URL: https://refactoring.guru/refactoring (дата звернення: 30.11.2025).
3. TypeScript Official Documentation. URL: https://www.typescriptlang.org/docs (дата звернення: 30.11.2025).
4. Clean Code concepts adapted for TypeScript. URL: https://github.com/labs42io/clean-code-typescript (дата звернення: 30.11.2025).

 

ДОДАТОК А
Відеозапис
Відеозапис доповіді: https://youtu.be/Hoy3OV2VqfA

     Хронологічний опис відеозапису:
0:00 – Вступ
0:19 – Що таке рефакторинґ?
0:46 – Інструменти для рефакторинґу
1:09 – Метод 1: Convert Procedural Design to Objects
1:29 – Convert Procedural Design to Objects – приклад
2:11 – Метод 2: Replace Data Value with Object
2:30 – Replace Data Value with Object – приклад
3:10 – Метод 3: Replace Method with Method Object
3:29 – Replace Method with Method Object – приклад
4:17 – Чому ці методи важливі?
4:31 – Рефакторинґ у командній роботі
4:43 – Висновок
5:03 – Джерела






ДОДАТОК Б
Слайди презентації

Рисунок Б.1 – Титульний слайд презентації


Рисунок Б.2 – Що таке рефакторинґ


Рисунок Б.3 – Інструменти для рефакторинґу


Рисунок Б.4 – Метод 1: Convert Procedural Design to Objects



Рисунок Б.5 – Convert Procedural Design to Objects - приклад


Рисунок Б.6 – Метод 2: Replace Data Value with Object


Рисунок Б.7 – Replace Data Value with Object - приклад


Рисунок Б.8 – Метод 3: Replace Method with Method Object

Рисунок Б.9 – Replace Method with Method Object - приклад


Рисунок Б.10 – Чому ці методи важливі?

Рисунок Б.11 – Рефакторинґ у командній роботі


Рисунок Б.12 – Висновки


	Рисунок Б.13 – Джерела


2


